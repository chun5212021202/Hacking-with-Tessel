var util = require('util');
var EventEmitter = require('events').EventEmitter;


//define parameters
var row = 4;
var col = 4;

var row1 = ['1','2','3','A'];
var row2 = ['4','5','6','B'];
var row3 = ['7','8','9','C'];
var row4 = ['*','0','#','D'];
var keys = [row1,row2,row3,row4];
//key state
var NO_KEY = 'X';


//state
var IDLE = 0;
var PRESSED = 1; 
var RELEASED = 2;
var HOLD = 3;

//get time
var startTime = new Date().getTime();
var time = function(){
	return new Date().getTime();
};




function Pad(hardware_row, hardware_column){  // 2 arrays
	var self = this;
	self.hardware_row = hardware_row;
	self.hardware_column = hardware_column;

	var lastUpdate = 0;
	var debounceTime = 50;
	var holdTime = 2000;
	var keypadEventListener = 0;
	var currentKey = NO_KEY;
	var state = IDLE;
	
	//initializePins();
	for (var i = hardware_column.length - 1; i >= 0; i--) {
		hardware_column[i].output(1);
		for (var i = hardware_row.length - 1; i >= 0; i--) {
			hardware_row[i].input();
		};
	};



	setImmediate(function emitReady() {
		self.emit('ready');
	});

}
util.inherits(Pad, EventEmitter);


Pad.prototype.start = function(samplerate){

  var self = this;
  console.log('qwewq');
  self.intervalhandler = setInterval(function () {
		var button = getKey(self.hardware_row, self.hardware_column);
  		//console.log('@@',button);
		switch(button){
			case '1':
				self.emit('1');
				break;
			case '2':
				self.emit('2');
				break;
			case '3':
				self.emit('3');
				break;
			case 'A':
				self.emit('A');
				break;
			case '4':
				self.emit('4');
				break;
			case '5':
				self.emit('5');
				break;
			case '6':
				self.emit('6');
				break;
			case 'B':
				self.emit('B');
				break;
			case '7':
				self.emit('7');
				break;
			case '8':
				self.emit('8');
				break;
			case '9':
				self.emit('9');
				break;
			case 'C':
				self.emit('C');
				break;
			case '*':
				self.emit('*');
				break;
			case '0':
				self.emit('0');
				break;
			case '#':
				self.emit('#');
				break;
			case 'D':
				self.emit('D');
				break;
		}

  }, samplerate);
};

Pad.prototype.stop= function(){
  var self = this;
	clearInterval(self.intervalhandler);
};

function use(hardware_row, hardware_column) {
  return new Pad(hardware_row, hardware_column);
}

exports.Pad = Pad;
exports.use = use;

var getKey = function(hardware_row, hardware_column){
	var x = NO_KEY;
	for (var c = 0; c < col; c++){
		hardware_column[c].output(0);
		for(var r = 0; r<row; r++){
			if(currentKey === keys[r][c]){
				//console.log(1);
				if((time() - startTime - lastUpdate >= holdTime) && (hardware_row[r].rawRead() === 0)){
					state = HOLD;
					//console.log(1,'HOLD');
					//do something
				}
				if((time() - startTime - lastUpdate >= debounceTime) && (hardware_row[r].rawRead() === 1)){
					state = RELEASED;
					//do something
					currentKey = NO_KEY;
					//console.log(1,'RELEASED');
				}
			}
			else if((time() - startTime - lastUpdate >= debounceTime) && (hardware_row[r].rawRead() === 0)){
				hardware_column[c].output(1);
				x = keys[r][c];
				lastUpdate = time()-startTime;
				if(x !== NO_KEY && x !== currentKey){
					//console.log(2,'PRESSED');
					currentKey = x;
					state = PRESSED;
					//do something
					return currentKey;
				}
				else{
					return NO_KEY;
				}

			}
		};
	};
};

